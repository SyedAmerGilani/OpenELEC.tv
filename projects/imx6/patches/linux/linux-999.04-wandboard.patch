diff --git a/arch/arm/boot/dts/imx6dl-wandboard.dts b/arch/arm/boot/dts/imx6dl-wandboard.dts
index e672891..b476518 100644
--- a/arch/arm/boot/dts/imx6dl-wandboard.dts
+++ b/arch/arm/boot/dts/imx6dl-wandboard.dts
@@ -9,14 +9,34 @@
  *
  */
 /dts-v1/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
 #include "imx6dl.dtsi"
 #include "imx6qdl-wandboard.dtsi"
 
 / {
 	model = "Wandboard i.MX6 Dual Lite Board";
 	compatible = "wand,imx6dl-wandboard", "fsl,imx6dl";
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+#if 0
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&mxcfb4 {
+	status = "okay";
+};
+#endif
 
-	memory {
-		reg = <0x10000000 0x40000000>;
-	};
+&epdc {
+	status = "disabled";
 };
diff --git a/arch/arm/boot/dts/imx6q-wandboard.dts b/arch/arm/boot/dts/imx6q-wandboard.dts
index 36be17f..48dc770 100644
--- a/arch/arm/boot/dts/imx6q-wandboard.dts
+++ b/arch/arm/boot/dts/imx6q-wandboard.dts
@@ -1,25 +1,45 @@
 /*
- * Copyright 2013 Freescale Semiconductor, Inc.
+ * Copyright 2014 John Weber
+ * Copyright 2013 Boundary Devices
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
  *
- * Author: Fabio Estevam <fabio.estevam@freescale.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
  *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
+
 /dts-v1/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
 #include "imx6q.dtsi"
 #include "imx6qdl-wandboard.dtsi"
 
 / {
-	model = "Wandboard i.MX6 Quad Board";
-	compatible = "wand,imx6q-wandboard", "fsl,imx6q";
+	model = "Wandboard Quad based on Freescale i.MX6 Quad";
+	compatible = "fsl,imx6q-wandboard", "fsl,imx6q";
+};
+
+&mxcfb1 {
+	status = "okay";
+};
 
-	memory {
-		reg = <0x10000000 0x80000000>;
-	};
+#if 0
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&mxcfb4 {
+	status = "okay";
 };
+#endif
 
 &sata {
 	status = "okay";
diff --git a/arch/arm/boot/dts/imx6qdl-wandboard.dtsi b/arch/arm/boot/dts/imx6qdl-wandboard.dtsi
index bdfdf89..f164c0a 100644
--- a/arch/arm/boot/dts/imx6qdl-wandboard.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-wandboard.dtsi
@@ -1,42 +1,69 @@
 /*
- * Copyright 2013 Freescale Semiconductor, Inc.
+ * Copyright 2014 John Weber, Avnet Electronics Marketing
+ * Copyright 2013 Boundary Devices
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
  *
- * Author: Fabio Estevam <fabio.estevam@freescale.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
  *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 / {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+	};
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
 	regulators {
 		compatible = "simple-bus";
-		#address-cells = <1>;
-		#size-cells = <0>;
 
-		reg_2p5v: regulator@0 {
+		reg_1p8v: 1p8v {
+			compatible = "regulator-fixed";
+			regulator-name = "1P8V";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-always-on;
+		};
+
+		reg_2p5v: 2p5v {
 			compatible = "regulator-fixed";
-			reg = <0>;
 			regulator-name = "2P5V";
 			regulator-min-microvolt = <2500000>;
 			regulator-max-microvolt = <2500000>;
 			regulator-always-on;
 		};
 
-		reg_3p3v: regulator@1 {
+		reg_3p3v: 3p3v {
 			compatible = "regulator-fixed";
-			reg = <1>;
 			regulator-name = "3P3V";
 			regulator-min-microvolt = <3300000>;
 			regulator-max-microvolt = <3300000>;
 			regulator-always-on;
 		};
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio3 22 0>;
+			enable-active-high;
+		};
 	};
 
 	sound {
-		compatible = "fsl,imx6-wandboard-sgtl5000",
-			     "fsl,imx-audio-sgtl5000";
+		compatible = "fsl,imx6-wandboard-sgtl5000", 
+                             "fsl,imx-audio-sgtl5000";
 		model = "imx6-wandboard-sgtl5000";
 		ssi-controller = <&ssi1>;
 		audio-codec = <&codec>;
@@ -48,26 +75,196 @@
 		mux-ext-port = <3>;
 	};
 
-	sound-spdif {
-		compatible = "fsl,imx-audio-spdif";
-		model = "imx-spdif";
-		spdif-controller = <&spdif>;
-		spdif-out;
+        sound-spdif {
+                compatible = "fsl,imx-audio-spdif";
+                model = "imx-spdif";
+                spdif-controller = <&spdif>;
+                spdif-out;
+        };
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+        rfkill {
+                compatible = "wand,imx6qdl-wandboard-rfkill";
+                pinctrl-names = "default";
+                pinctrl-0 = <>;
+
+                bluetooth-on = <&gpio3 13 0>;
+                bluetooth-wake = <&gpio3 14 0>;
+                bluetooth-host-wake = <&gpio3 15 0>;
+
+                wifi-ref-on = <&gpio2 29 0>;
+                wifi-rst-n = <&gpio5 2 0>;
+                wifi-reg-on = <&gpio1 26 0>;
+                wifi-host-wake = <&gpio1 29 0>;
+                wifi-wake = <&gpio1 30 0>;
+
+		/* Rev C1 gpio definitions */
+                bluetooth-on-revc1 = <&gpio5 21 0>;
+                bluetooth-wake-revc1 = <&gpio5 30 0>;
+                bluetooth-host-wake-revc1 = <&gpio5 20 0>;
+
+                wifi-ref-on-revc1 = <&gpio5 31 0>;
+                wifi-rst-n-revc1 = <&gpio6 0 0>;
+
+		/* Rev B/C probe gpio */
+		wand-rev-gpio = <&gpio2 28 0>;
+        };
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str ="1920x1080M@60";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+        mxcfb2: fb@1 {
+                compatible = "fsl,mxc_sdc_fb";
+                disp_dev = "ldb";
+                interface_pix_fmt = "RGB666";
+                mode_str ="LDB-XGA";
+                default_bpp = <16>;
+                int_clk = <0>;
+                late_init = <0>;
+                status = "disabled";
+        };
+
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB565";
+		mode_str ="CLAA-WVGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB666";
+		mode_str ="LDB-XGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB565";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_1>;
+		status = "okay";
+	};
+
+	backlight_lcd {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+	};
+
+	backlight_lvds {
+		compatible = "pwm-backlight";
+		pwms = <&pwm4 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
 	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+
 };
 
+
 &audmux {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_audmux>;
+	pinctrl-0 = <&pinctrl_audmux_2>;
 	status = "okay";
 };
 
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_3>;
+	phy-mode = "rgmii";
+	status = "okay";
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <0>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_1>;
+	status = "okay";
+
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+
+};
+
 &i2c2 {
 	clock-frequency = <100000>;
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c2>;
+	pinctrl-0 = <&pinctrl_i2c2_2>;
 	status = "okay";
 
+	ov5640_mipi: ov5640_mipi@3c {
+		compatible = "ovti,ov5640_mipi";
+		reg = <0x3c>;
+		clocks = <&clks 200>;
+		clock-names = "csi_mclk";
+		DOVDD-supply = <&reg_1p8v>;
+		AVDD-supply = <&reg_2p5v>;
+		DVDD-supply = <&reg_1p8v>;
+		pwn-gpios = <&gpio1 6 1>;
+		rst-gpios = <&gpio4 14 0>;
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+	};
+
 	codec: sgtl5000@0a {
 		compatible = "fsl,sgtl5000";
 		reg = <0x0a>;
@@ -75,144 +272,592 @@
 		VDDA-supply = <&reg_2p5v>;
 		VDDIO-supply = <&reg_3p3v>;
 	};
+
+	fusion7: fusion7@10 {
+		compatible = "touchrev,fusion7";
+		reg = <0x10>; /* The reg property describes the address of the device's resources within the address space defined by its parent bus.  */
+		pinctrl-0 = <&pinctrl_gpio>;
+		pinctrl-names = "default";
+		interrupt-parent = <&gpio4>;
+		interrupts = <5 0>;
+		reset-gpios=<&gpio7 8 0>; /*pin264  SD3_RST GPIO(7, 8)   gpio200   Touchscreen Reset  Output*/
+		touch_xmax=<1499>;
+		touch_ymax=<899>;
+		flip_x=<0>;
+		flip_y=<0>;
+	};
+
+};
+
+&i2c3 {
+        clock-frequency = <100000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_i2c3_3>;
+        status = "okay";
 };
 
+/*
+For reference here, the PAD_CTL bitfield definition from
+Documentation/devicetree/bindings/pinctrl/fsl,imx6q-pinctrl.txt
+
+CONFIG bits definition:
+PAD_CTL_HYS                     (1 << 16)
+PAD_CTL_PUS_100K_DOWN           (0 << 14)
+PAD_CTL_PUS_47K_UP              (1 << 14)
+PAD_CTL_PUS_100K_UP             (2 << 14)
+PAD_CTL_PUS_22K_UP              (3 << 14)
+PAD_CTL_PUE                     (1 << 13)
+PAD_CTL_PKE                     (1 << 12)
+PAD_CTL_ODE                     (1 << 11)
+PAD_CTL_SPEED_LOW               (1 << 6)
+PAD_CTL_SPEED_MED               (2 << 6)
+PAD_CTL_SPEED_HIGH              (3 << 6)
+PAD_CTL_DSE_DISABLE             (0 << 3)
+PAD_CTL_DSE_240ohm              (1 << 3)
+PAD_CTL_DSE_120ohm              (2 << 3)
+PAD_CTL_DSE_80ohm               (3 << 3)
+PAD_CTL_DSE_60ohm               (4 << 3)
+PAD_CTL_DSE_48ohm               (5 << 3)
+PAD_CTL_DSE_40ohm               (6 << 3)
+PAD_CTL_DSE_34ohm               (7 << 3)
+PAD_CTL_SRE_FAST                (1 << 0)
+PAD_CTL_SRE_SLOW                (0 << 0)
+
+Example, the Control Pad Setting
+
+    0x0f0b0
+
+corresponds to:
+
+   0b1111000010110000
+
+which is:
+
+   PAD_CTL_PUS_22K_UP | PAD_CTL_PUE | PAD_CTL_PKE |
+   PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm
+
+For more information about this, refer to the IOMUXC section of the i.MX6
+reference manual.
+
+*/
+
 &iomuxc {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_hog>;
+	pinctrl-0 = <&pinctrl_hog_1>;
 
 	imx6qdl-wandboard {
-		pinctrl_hog: hoggrp {
+		pinctrl_hog_1: hoggrp-1 {
 			fsl,pins = <
-				MX6QDL_PAD_GPIO_0__CCM_CLKO1 	 0x130b0
-				MX6QDL_PAD_GPIO_2__GPIO1_IO02	 0x80000000
-				MX6QDL_PAD_EIM_DA9__GPIO3_IO09	 0x80000000
-				MX6QDL_PAD_EIM_EB1__GPIO2_IO29   0x80000000 /* WL_REF_ON */
-				MX6QDL_PAD_EIM_A25__GPIO5_IO02   0x80000000 /* WL_RST_N */
-				MX6QDL_PAD_ENET_RXD1__GPIO1_IO26 0x80000000 /* WL_REG_ON */
-				MX6QDL_PAD_ENET_TXD1__GPIO1_IO29 0x80000000 /* WL_HOST_WAKE */
-				MX6QDL_PAD_ENET_TXD0__GPIO1_IO30 0x80000000 /* WL_WAKE */
-				MX6QDL_PAD_EIM_D29__GPIO3_IO29   0x80000000
+				MX6QDL_PAD_GPIO_0__CCM_CLKO1     	0x130b0
+				MX6QDL_PAD_EIM_D22__USB_OTG_PWR		0x80000000	/* USB Power Enable */
+				MX6QDL_PAD_GPIO_2__GPIO1_IO02		0x80000000	/* USDHC1 CD */
+				MX6QDL_PAD_EIM_DA9__GPIO3_IO09		0x80000000	/* uSDHC3 CD */
+				MX6QDL_PAD_GPIO_0__CCM_CLKO1		0x000b0		/* SGTL5000 sys_mclk */
+				MX6QDL_PAD_GPIO_6__GPIO1_IO06		0x0b0b0		/* ov5640 mipi powerdown */
+				MX6QDL_PAD_KEY_COL4__GPIO4_IO14		0x000b0		/* ov5640 mipi reset */
+				MX6QDL_PAD_GPIO_3__CCM_CLKO2		0x000b0		/* ov5640 mclk */
+				MX6QDL_PAD_EIM_A25__GPIO5_IO02		0x0f0b0		/* WIFI_ON (reset, active low) */
+				MX6QDL_PAD_ENET_RXD1__GPIO1_IO26	0x000b0		/* WL_REG_ON (unused) */
+				MX6QDL_PAD_ENET_TXD1__GPIO1_IO29	0x80000000	/* WL_HOST_WAKE, input */
+				MX6QDL_PAD_EIM_EB1__GPIO2_IO29		0x0f0b0		/* EIM_EB1 (Wifi Power Enable) */
+				MX6QDL_PAD_ENET_TXD0__GPIO1_IO30	0x80000000	/* WL_WAKE (unused) */
+                                MX6QDL_PAD_EIM_D29__GPIO3_IO29   	0x80000000
+                                MX6QDL_PAD_EIM_DA13__GPIO3_IO13  	0x80000000 	/* BT_ON */
+                                MX6QDL_PAD_EIM_DA14__GPIO3_IO14  	0x80000000 	/* BT_WAKE */
+                                MX6QDL_PAD_EIM_DA15__GPIO3_IO15  	0x80000000 	/* BT_HOST_WAKE */
+				MX6QDL_PAD_EIM_EB0__GPIO2_IO28		0x1B880         /* Wandboard C1 Revision check */
+				/* GPIO used in Wandboard rev C1 */
+				MX6QDL_PAD_CSI0_DAT14__GPIO6_IO00	0x0f0b0		/* WIFI_ON (reset, active low) */
+				MX6QDL_PAD_CSI0_DAT13__GPIO5_IO31	0x0f0b0		/* GPIO5_IO31 (Wifi Power Enable) */
+				MX6QDL_PAD_CSI0_VSYNC__GPIO5_IO21	0x80000000	/* BT_ON */
+				MX6QDL_PAD_CSI0_DAT12__GPIO5_IO30	0x80000000	/* BT_WAKE */
+				MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20     0x80000000	/*BT_HOST_WAKE */
 			>;
 		};
 
-		pinctrl_audmux: audmuxgrp {
-			fsl,pins = <
-				MX6QDL_PAD_CSI0_DAT7__AUD3_RXD		0x130b0
-				MX6QDL_PAD_CSI0_DAT4__AUD3_TXC		0x130b0
-				MX6QDL_PAD_CSI0_DAT5__AUD3_TXD		0x110b0
-				MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS		0x130b0
+	        pinctrl_spdif_wand: spdifgrp {
+	                fsl,pins = <
+				MX6QDL_PAD_ENET_RXD0__SPDIF_OUT                 0x1b0b0
 			>;
-		};
-
-		pinctrl_enet: enetgrp {
+	        };
+	};
+	gpio {
+		pinctrl_gpio: gpiogrp {
 			fsl,pins = <
-				MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
-				MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
-				MX6QDL_PAD_RGMII_TXC__RGMII_TXC		0x1b0b0
-				MX6QDL_PAD_RGMII_TD0__RGMII_TD0		0x1b0b0
-				MX6QDL_PAD_RGMII_TD1__RGMII_TD1		0x1b0b0
-				MX6QDL_PAD_RGMII_TD2__RGMII_TD2		0x1b0b0
-				MX6QDL_PAD_RGMII_TD3__RGMII_TD3		0x1b0b0
-				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL	0x1b0b0
-				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK	0x1b0b0
-				MX6QDL_PAD_RGMII_RXC__RGMII_RXC		0x1b0b0
-				MX6QDL_PAD_RGMII_RD0__RGMII_RD0		0x1b0b0
-				MX6QDL_PAD_RGMII_RD1__RGMII_RD1		0x1b0b0
-				MX6QDL_PAD_RGMII_RD2__RGMII_RD2		0x1b0b0
-				MX6QDL_PAD_RGMII_RD3__RGMII_RD3		0x1b0b0
-				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL	0x1b0b0
-				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x4001b0a8
-				MX6QDL_PAD_GPIO_6__ENET_IRQ		0x000b1
+                                MX6QDL_PAD_EIM_DA12__GPIO3_IO12   0x4001b0b0 /* GPIO3_12 EDM pin 255 */
+                                MX6QDL_PAD_EIM_DA11__GPIO3_IO11   0x4001b0b0 /* GPIO3_11 EDM pin 256 */
+                                MX6QDL_PAD_EIM_DA10__GPIO3_IO10   0x4001b0b0 /* GPIO3_10 EDM pin 257 */
+                                MX6QDL_PAD_EIM_D27__GPIO3_IO27    0x4001b0b0 /* GPIO3_27 EDM pin 258 */
+                                MX6QDL_PAD_EIM_D26__GPIO3_IO26    0x4001b0b0 /* GPIO3_26 EDM pin 259 */
+                                MX6QDL_PAD_EIM_BCLK__GPIO6_IO31   0x4001b0b0 /* GPIO6_31 EDM pin 260 */
+                                MX6QDL_PAD_EIM_DA8__GPIO3_IO08    0x4001b0b0 /* GPIO3_8  EDM pin 261 */
+                                MX6QDL_PAD_ENET_RX_ER__GPIO1_IO24 0x4001b0b0 /* GPIO1_24 EDM pin 262 */
+                                MX6QDL_PAD_GPIO_19__GPIO4_IO05    0x4001b0b0 /* GPIO4_5  EDM pin 263 */
+                                MX6QDL_PAD_SD3_RST__GPIO7_IO08    0x4001b0b0 /* GPIO7_8  EDM pin 264 */
 			>;
 		};
+	};
 
-		pinctrl_i2c2: i2c2grp {
-			fsl,pins = <
-				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001b8b1
-				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001b8b1
-			>;
-		};
+	usdhc1 {
+                pinctrl_usdhc1_1: usdhc1grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_SD1_CMD__SD1_CMD    0x17071
+                                MX6QDL_PAD_SD1_CLK__SD1_CLK    0x10071
+                                MX6QDL_PAD_SD1_DAT0__SD1_DATA0 0x17071
+                                MX6QDL_PAD_SD1_DAT1__SD1_DATA1 0x17071
+                                MX6QDL_PAD_SD1_DAT2__SD1_DATA2 0x17071
+                                MX6QDL_PAD_SD1_DAT3__SD1_DATA3 0x17071
+                        >;
+                };
+        };
 
-		pinctrl_spdif: spdifgrp {
-			fsl,pins = <
-				MX6QDL_PAD_ENET_RXD0__SPDIF_OUT		0x1b0b0
-			>;
-		};
+        usdhc2 {
+                pinctrl_usdhc2_1: usdhc2grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_SD2_CMD__SD2_CMD    0x17059
+                                MX6QDL_PAD_SD2_CLK__SD2_CLK    0x10059
+                                MX6QDL_PAD_SD2_DAT0__SD2_DATA0 0x17059
+                                MX6QDL_PAD_SD2_DAT1__SD2_DATA1 0x17059
+                                MX6QDL_PAD_SD2_DAT2__SD2_DATA2 0x17059
+                                MX6QDL_PAD_SD2_DAT3__SD2_DATA3 0x17059
+                                MX6QDL_PAD_NANDF_D4__SD2_DATA4 0x17059
+                                MX6QDL_PAD_NANDF_D5__SD2_DATA5 0x17059
+                                MX6QDL_PAD_NANDF_D6__SD2_DATA6 0x17059
+                                MX6QDL_PAD_NANDF_D7__SD2_DATA7 0x17059
+                        >;
+                };
 
-		pinctrl_uart1: uart1grp {
-			fsl,pins = <
-				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA	0x1b0b1
-				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA	0x1b0b1
-			>;
-		};
+                pinctrl_usdhc2_2: usdhc2grp-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_SD2_CMD__SD2_CMD    0x17059
+                                MX6QDL_PAD_SD2_CLK__SD2_CLK    0x10059
+                                MX6QDL_PAD_SD2_DAT0__SD2_DATA0 0x17059
+                                MX6QDL_PAD_SD2_DAT1__SD2_DATA1 0x17059
+                                MX6QDL_PAD_SD2_DAT2__SD2_DATA2 0x17059
+                                MX6QDL_PAD_SD2_DAT3__SD2_DATA3 0x17059
+                        >;
+                };
+        };
 
-		pinctrl_uart3: uart3grp {
-			fsl,pins = <
-				MX6QDL_PAD_EIM_D24__UART3_TX_DATA	0x1b0b1
-				MX6QDL_PAD_EIM_D25__UART3_RX_DATA	0x1b0b1
-				MX6QDL_PAD_EIM_D23__UART3_CTS_B		0x1b0b1
-				MX6QDL_PAD_EIM_EB3__UART3_RTS_B		0x1b0b1
-			>;
-		};
 
-		pinctrl_usbotg: usbotggrp {
-			fsl,pins = <
-				MX6QDL_PAD_GPIO_1__USB_OTG_ID		0x17059
-			>;
-		};
+        usdhc3 {
+                pinctrl_usdhc3_1: usdhc3grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_SD3_CMD__SD3_CMD    0x17059
+                                MX6QDL_PAD_SD3_CLK__SD3_CLK    0x10059
+                                MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x17059
+                                MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x17059
+                                MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x17059
+                                MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x17059
+                                MX6QDL_PAD_SD3_DAT4__SD3_DATA4 0x17059
+                                MX6QDL_PAD_SD3_DAT5__SD3_DATA5 0x17059
+                                MX6QDL_PAD_SD3_DAT6__SD3_DATA6 0x17059
+                                MX6QDL_PAD_SD3_DAT7__SD3_DATA7 0x17059
+                        >;
+                };
 
-		pinctrl_usdhc1: usdhc1grp {
-			fsl,pins = <
-				MX6QDL_PAD_SD1_CMD__SD1_CMD		0x17059
-				MX6QDL_PAD_SD1_CLK__SD1_CLK		0x10059
-				MX6QDL_PAD_SD1_DAT0__SD1_DATA0		0x17059
-				MX6QDL_PAD_SD1_DAT1__SD1_DATA1		0x17059
-				MX6QDL_PAD_SD1_DAT2__SD1_DATA2		0x17059
-				MX6QDL_PAD_SD1_DAT3__SD1_DATA3		0x17059
-			>;
-		};
+                pinctrl_usdhc3_1_100mhz: usdhc3grp-1-100mhz { /* 100Mhz */
+                        fsl,pins = <
+                                MX6QDL_PAD_SD3_CMD__SD3_CMD 0x170B9
+                                MX6QDL_PAD_SD3_CLK__SD3_CLK 0x100B9
+                                MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x170B9
+                                MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x170B9
+                                MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x170B9
+                                MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x170B9
+                                MX6QDL_PAD_SD3_DAT4__SD3_DATA4 0x170B9
+                                MX6QDL_PAD_SD3_DAT5__SD3_DATA5 0x170B9
+                                MX6QDL_PAD_SD3_DAT6__SD3_DATA6 0x170B9
+                                MX6QDL_PAD_SD3_DAT7__SD3_DATA7 0x170B9
+                        >;
+                };
 
-		pinctrl_usdhc2: usdhc2grp {
-			fsl,pins = <
-				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x17059
-				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x10059
-				MX6QDL_PAD_SD2_DAT0__SD2_DATA0		0x17059
-				MX6QDL_PAD_SD2_DAT1__SD2_DATA1		0x17059
-				MX6QDL_PAD_SD2_DAT2__SD2_DATA2		0x17059
-				MX6QDL_PAD_SD2_DAT3__SD2_DATA3		0x17059
-			>;
-		};
+                pinctrl_usdhc3_1_200mhz: usdhc3grp-1-200mhz { /* 200Mhz */
+                        fsl,pins = <
+                                MX6QDL_PAD_SD3_CMD__SD3_CMD 0x170F9
+                                MX6QDL_PAD_SD3_CLK__SD3_CLK 0x100F9
+                                MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x170F9
+                                MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x170F9
+                                MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x170F9
+                                MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x170F9
+                                MX6QDL_PAD_SD3_DAT4__SD3_DATA4 0x170F9
+                                MX6QDL_PAD_SD3_DAT5__SD3_DATA5 0x170F9
+                                MX6QDL_PAD_SD3_DAT6__SD3_DATA6 0x170F9
+                                MX6QDL_PAD_SD3_DAT7__SD3_DATA7 0x170F9
+                        >;
+                };
+
+                pinctrl_usdhc3_2: usdhc3grp-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_SD3_CMD__SD3_CMD    0x17059
+                                MX6QDL_PAD_SD3_CLK__SD3_CLK    0x10059
+                                MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x17059
+                                MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x17059
+                                MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x17059
+                                MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x17059
+                        >;
+                };
+        };
+
+
+	enet {
+                pinctrl_enet_1: enetgrp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_ENET_MDIO__ENET_MDIO       0x1b0b0
+                                MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
+                                MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
+                                MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
+                                MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
+                                MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
+                                MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0
+                                MX6QDL_PAD_GPIO_16__ENET_REF_CLK      0x4001b0a8
+                        >;
+                };
+
+                pinctrl_enet_2: enetgrp-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_KEY_COL1__ENET_MDIO        0x1b0b0
+                                MX6QDL_PAD_KEY_COL2__ENET_MDC         0x1b0b0
+                                MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
+                                MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
+                                MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
+                                MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
+                                MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0
+                                MX6QDL_PAD_GPIO_16__ENET_REF_CLK      0x4001b0a8
+                        >;
+                };
+
+                pinctrl_enet_3: enetgrp-3 {
+                        fsl,pins = <
+                                MX6QDL_PAD_ENET_MDIO__ENET_MDIO       0x1b0b0
+                                MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
+                                MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
+                                MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
+                                MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
+                                MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
+                                MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
+                                MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
+                                MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0
+                                MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN     0x1b0b0
+                        >;
+                };
+        };
+
+
+        usbotg {
+                pinctrl_usbotg_1: usbotggrp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_GPIO_1__USB_OTG_ID 0x17059
+                        >;
+                };
+
+                pinctrl_usbotg_2: usbotggrp-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID 0x17059
+                        >;
+                };
+        };
+
+        i2c1 {
+                pinctrl_i2c1_1: i2c1grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D21__I2C1_SCL 0x4001b8b1
+                                MX6QDL_PAD_EIM_D28__I2C1_SDA 0x4001b8b1
+                        >;
+                };
+
+                pinctrl_i2c1_2: i2c1grp-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_CSI0_DAT8__I2C1_SDA 0x4001b8b1
+                                MX6QDL_PAD_CSI0_DAT9__I2C1_SCL 0x4001b8b1
+                        >;
+                };
+        };
+
+        i2c2 {
+                pinctrl_i2c2_1: i2c2grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_EB2__I2C2_SCL 0x4001b8b1
+                                MX6QDL_PAD_EIM_D16__I2C2_SDA 0x4001b8b1
+                        >;
+                };
+
+                pinctrl_i2c2_2: i2c2grp-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_KEY_COL3__I2C2_SCL 0x4001b8b1
+                                MX6QDL_PAD_KEY_ROW3__I2C2_SDA 0x4001b8b1
+                        >;
+                };
+
+                pinctrl_i2c2_3: i2c2grp-3 {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_EB2__I2C2_SCL  0x4001b8b1
+                                MX6QDL_PAD_KEY_ROW3__I2C2_SDA 0x4001b8b1
+                        >;
+                };
+        };
+
+
+
+        i2c3 {
+                pinctrl_i2c3_1: i2c3grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D17__I2C3_SCL 0x4001b8b1
+                                MX6QDL_PAD_EIM_D18__I2C3_SDA 0x4001b8b1
+                        >;
+                };
+
+                pinctrl_i2c3_2: i2c3grp-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_GPIO_3__I2C3_SCL 0x4001b8b1
+                                MX6QDL_PAD_GPIO_6__I2C3_SDA 0x4001b8b1
+                        >;
+                };
+
+                pinctrl_i2c3_3: i2c3grp-3 {
+                        fsl,pins = <
+                                MX6QDL_PAD_GPIO_5__I2C3_SCL  0x4001b8b1
+                                MX6QDL_PAD_GPIO_16__I2C3_SDA 0x4001b8b1
+                        >;
+                };
+
+                pinctrl_i2c3_4: i2c3grp-4 {
+                        fsl,pins = <
+                                MX6QDL_PAD_GPIO_3__I2C3_SCL  0x4001b8b1
+                                MX6QDL_PAD_EIM_D18__I2C3_SDA 0x4001b8b1
+                        >;
+                };
+        };
+
+
+        ipu1 {
+                pinctrl_ipu1_1: ipu1grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x10
+                                MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15       0x10
+                                MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02        0x10
+                                MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03        0x10
+                                MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04        0x80000000
+                                MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
+                                MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
+                                MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
+                                MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
+                                MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
+                                MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
+                                MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
+                                MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10
+                                MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0x10
+                                MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0x10
+                                MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0x10
+                                MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0x10
+                                MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0x10
+                                MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0x10
+                                MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0x10
+                                MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0x10
+                                MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0x10
+                                MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0x10
+                                MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18  0x10
+                                MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19  0x10
+                                MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20  0x10
+                                MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21  0x10
+                                MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22  0x10
+                                MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23  0x10
+                        >;
+                };
+
+                pinctrl_ipu1_2: ipu1grp-2 { /* parallel camera */
+                        fsl,pins = <
+                                MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12    0x80000000
+                                MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13    0x80000000
+                                MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14    0x80000000
+                                MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15    0x80000000
+                                MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16    0x80000000
+                                MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17    0x80000000
+                                MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18    0x80000000
+                                MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19    0x80000000
+                                MX6QDL_PAD_CSI0_DATA_EN__IPU1_CSI0_DATA_EN 0x80000000
+                                MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK   0x80000000
+                                MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC      0x80000000
+                                MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC     0x80000000
+                        >;
+                };
+
+                pinctrl_ipu1_3: ipu1grp-3 { /* parallel port 16-bit */
+                        fsl,pins = <
+                                MX6QDL_PAD_CSI0_DAT4__IPU1_CSI0_DATA04   0x80000000
+                                MX6QDL_PAD_CSI0_DAT5__IPU1_CSI0_DATA05   0x80000000
+                                MX6QDL_PAD_CSI0_DAT6__IPU1_CSI0_DATA06   0x80000000
+                                MX6QDL_PAD_CSI0_DAT7__IPU1_CSI0_DATA07   0x80000000
+                                MX6QDL_PAD_CSI0_DAT8__IPU1_CSI0_DATA08   0x80000000
+                                MX6QDL_PAD_CSI0_DAT9__IPU1_CSI0_DATA09   0x80000000
+                                MX6QDL_PAD_CSI0_DAT10__IPU1_CSI0_DATA10  0x80000000
+                                MX6QDL_PAD_CSI0_DAT11__IPU1_CSI0_DATA11  0x80000000
+                                MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12  0x80000000
+                                MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13  0x80000000
+                                MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14  0x80000000
+                                MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15  0x80000000
+                                MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16  0x80000000
+                                MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17  0x80000000
+                                MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18  0x80000000
+                                MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19  0x80000000
+                                MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK 0x80000000
+                                MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC    0x80000000
+                                MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC   0x80000000
+                        >;
+                };
+        };
+
+
+       audmux {
+                pinctrl_audmux_1: audmux-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_SD2_DAT0__AUD4_RXD  0x130b0
+                                MX6QDL_PAD_SD2_DAT3__AUD4_TXC  0x130b0
+                                MX6QDL_PAD_SD2_DAT2__AUD4_TXD  0x110b0
+                                MX6QDL_PAD_SD2_DAT1__AUD4_TXFS 0x130b0
+                        >;
+                };
+
+                pinctrl_audmux_2: audmux-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_CSI0_DAT7__AUD3_RXD  0x130b0
+                                MX6QDL_PAD_CSI0_DAT4__AUD3_TXC  0x130b0
+                                MX6QDL_PAD_CSI0_DAT5__AUD3_TXD  0x110b0
+                                MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS 0x130b0
+                        >;
+                };
+
+                pinctrl_audmux_3: audmux-3 {
+                        fsl,pins = <
+                                MX6QDL_PAD_DISP0_DAT16__AUD5_TXC  0x130b0
+                                MX6QDL_PAD_DISP0_DAT18__AUD5_TXFS 0x130b0
+                                MX6QDL_PAD_DISP0_DAT19__AUD5_RXD  0x130b0
+                        >;
+                };
+        };
+
+
+	uart1 {
+                pinctrl_uart1_1: uart1grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA 0x1b0b1
+                                MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA 0x1b0b1
+                        >;
+                };
+        };
+
+        uart2 {
+                pinctrl_uart2_1: uart2grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D26__UART2_TX_DATA 0x1b0b1
+                                MX6QDL_PAD_EIM_D27__UART2_RX_DATA 0x1b0b1
+                        >;
+                };
+
+                pinctrl_uart2_2: uart2grp-2 { /* DTE mode */
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D26__UART2_RX_DATA   0x1b0b1
+                                MX6QDL_PAD_EIM_D27__UART2_TX_DATA   0x1b0b1
+                                MX6QDL_PAD_EIM_D28__UART2_DTE_CTS_B 0x1b0b1
+                                MX6QDL_PAD_EIM_D29__UART2_DTE_RTS_B 0x1b0b1
+                        >;
+                };
+        };
+
+        uart3 {
+                pinctrl_uart3_1: uart3grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_SD4_CLK__UART3_RX_DATA 0x1b0b1
+                                MX6QDL_PAD_SD4_CMD__UART3_TX_DATA 0x1b0b1
+                                MX6QDL_PAD_EIM_D30__UART3_CTS_B   0x1b0b1
+                                MX6QDL_PAD_EIM_EB3__UART3_RTS_B   0x1b0b1
+                        >;
+                };
+        };
+
+        uart4 {
+                pinctrl_uart4_1: uart4grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_KEY_COL0__UART4_TX_DATA 0x1b0b1
+                                MX6QDL_PAD_KEY_ROW0__UART4_RX_DATA 0x1b0b1
+                        >;
+                };
+        };
 
-		pinctrl_usdhc3: usdhc3grp {
-			fsl,pins = <
-				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17059
-				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x10059
-				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x17059
-				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x17059
-				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x17059
-				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x17059
-			>;
-		};
-	};
 };
 
-&fec {
+
+#if 0
+&ldb {
+	ipu_id = <0>;
+	disp_id = <1>;
+	ext_ref = <1>;
+	mode = "sin0";
+	sec_ipu_id = <1>;
+	sec_disp_id = <1>;
+	status = "okay";
+};
+#endif
+
+&mipi_csi {
+	ipu_id = <0>;
+	csi_id = <0>;
+	v_channel = <0>;
+	lanes = <2>;
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+};
+
+#if 0
+&pwm1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_enet>;
-	phy-mode = "rgmii";
-	phy-reset-gpios = <&gpio3 29 0>;
-	interrupts-extended = <&gpio1 6 IRQ_TYPE_LEVEL_HIGH>,
-			      <&intc 0 119 IRQ_TYPE_LEVEL_HIGH>;
+	pinctrl-0 = <&pinctrl_pwm1_1>;
 	status = "okay";
 };
 
-&spdif {
+&pwm3 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_spdif>;
+	pinctrl-0 = <&pinctrl_pwm3_2>;
 	status = "okay";
 };
 
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm4_2>;
+	status = "okay";
+};
+#endif
+
+&spdif {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_spdif_wand>;
+        status = "okay";
+};
+
 &ssi1 {
 	fsl,mode = "i2s-slave";
 	status = "okay";
@@ -220,15 +865,15 @@
 
 &uart1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_uart1>;
+	pinctrl-0 = <&pinctrl_uart1_1>;
 	status = "okay";
 };
 
 &uart3 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_uart3>;
-	fsl,uart-has-rtscts;
-	status = "okay";
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_uart3_2>;
+        fsl,uart-has-rtscts;
+        status = "okay";
 };
 
 &usbh1 {
@@ -236,30 +881,38 @@
 };
 
 &usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usbotg>;
+	pinctrl-0 = <&pinctrl_usbotg_1>;
 	disable-over-current;
-	dr_mode = "peripheral";
+	dr_mode = "otg";
 	status = "okay";
 };
 
-&usdhc1 {
+&usdhc1 {  /* Baseboard microSD slot */
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-0 = <&pinctrl_usdhc1_1>;
+	bus-width = <4>;
+	vmmc-supply = <&reg_3p3v>;
 	cd-gpios = <&gpio1 2 0>;
 	status = "okay";
 };
 
-&usdhc2 {
+&usdhc2 {  /* Broadcom Wifi/BT  */
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usdhc2>;
-	non-removable;
+	pinctrl-0 = <&pinctrl_usdhc2_2>;
+	bus-width = <4>;
+	//non-removable;
+	vmmc-supply = <&reg_3p3v>;
+	keep-power-in-suspend;
 	status = "okay";
 };
 
-&usdhc3 {
+&usdhc3 { /* Module microSD slot */
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usdhc3>;
-	cd-gpios = <&gpio3 9 0>;
+	pinctrl-0 = <&pinctrl_usdhc3_2>;
+	vmmc-supply = <&reg_3p3v>;
+        cd-gpios = <&gpio3 9 0>;
 	status = "okay";
 };
+
diff --git a/arch/arm/boot/dts/imx6qdl.dtsi b/arch/arm/boot/dts/imx6qdl.dtsi
index d3499f4..133ad09 100644
--- a/arch/arm/boot/dts/imx6qdl.dtsi
+++ b/arch/arm/boot/dts/imx6qdl.dtsi
@@ -149,16 +149,16 @@
 				  0x81000000 0 0          0x01f80000 0 0x00010000 /* downstream I/O */
 				  0x82000000 0 0x01000000 0x01000000 0 0x00f00000>; /* non-prefetchable memory */
 			num-lanes = <1>;
-			interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "pme";
+			interrupts = <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "msi";
 			#interrupt-cells = <1>;
 			interrupt-map-mask = <0 0 0 0x7>;
 			interrupt-map = <0 0 0 1 &intc GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>,
 			                <0 0 0 2 &intc GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>,
 			                <0 0 0 3 &intc GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>,
 			                <0 0 0 4 &intc GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&clks 144>, <&clks 221>, <&clks 189>, <&clks 187>;
-			clock-names = "pcie_axi", "lvds_gate", "pcie_ref_125m", "sata_ref_100m";
+			clocks = <&clks 144>, <&clks 206>, <&clks 189>, <&clks 221>;
+			clock-names = "pcie", "pcie_bus", "pcie_phy", "lvds_gate";
 			status = "disabled";
 		};
 
@@ -1073,5 +1073,13 @@
 			resets = <&src 2>;
 			bypass_reset = <0>;
 		};
+		pinctrl_uart3_2: uart3grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D24__UART3_TX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D25__UART3_RX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D23__UART3_CTS_B   0x1b0b1
+				MX6QDL_PAD_EIM_EB3__UART3_RTS_B   0x1b0b1
+			>;
+		};
 	};
 };
diff --git a/arch/arm/mach-imx/devices/Kconfig b/arch/arm/mach-imx/devices/Kconfig
index 68c74fb..a0adf75 100644
--- a/arch/arm/mach-imx/devices/Kconfig
+++ b/arch/arm/mach-imx/devices/Kconfig
@@ -85,3 +85,9 @@ config IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
 
 config IMX_HAVE_PLATFORM_SPI_IMX
 	bool
+
+config WAND_RFKILL
+	tristate "Wandboard RF Kill support"
+	depends on SOC_IMX6Q
+	default m
+	select RFKILL
diff --git a/arch/arm/mach-imx/devices/Makefile b/arch/arm/mach-imx/devices/Makefile
index 67416fb..b2aded5 100644
--- a/arch/arm/mach-imx/devices/Makefile
+++ b/arch/arm/mach-imx/devices/Makefile
@@ -30,3 +30,4 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_W1) += platform-mxc_w1.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX) += platform-sdhci-esdhc-imx.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_SPI_IMX) +=  platform-spi_imx.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_MX2_EMMA) += platform-mx2-emma.o
+obj-$(CONFIG_WAND_RFKILL) += wand-rfkill.o
diff --git a/arch/arm/mach-imx/devices/wand-rfkill.c b/arch/arm/mach-imx/devices/wand-rfkill.c
new file mode 100644
index 0000000..341e949
--- /dev/null
+++ b/arch/arm/mach-imx/devices/wand-rfkill.c
@@ -0,0 +1,329 @@
+/*
+ * arch/arm/mach-imx/devices/wand-rfkill.c
+ *
+ * Copyright (C) 2013 Vladimir Ermakov <vooon341@gmail.com>
+ *
+ * based on net/rfkill/rfkill-gpio.c
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/rfkill.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+
+struct wand_rfkill_data {
+	struct rfkill *rfkill_dev;
+	int shutdown_gpio;
+	const char *shutdown_name;
+};
+
+static int wand_rfkill_set_block(void *data, bool blocked)
+{
+	struct wand_rfkill_data *rfkill = data;
+
+	pr_debug("wandboard-rfkill: set block %d\n", blocked);
+
+	if (blocked) {
+		if (gpio_is_valid(rfkill->shutdown_gpio))
+			gpio_direction_output(rfkill->shutdown_gpio, 0);
+	} else {
+		if (gpio_is_valid(rfkill->shutdown_gpio))
+			gpio_direction_output(rfkill->shutdown_gpio, 1);
+	}
+
+	return 0;
+}
+
+static const struct rfkill_ops wand_rfkill_ops = {
+	.set_block = wand_rfkill_set_block,
+};
+
+static int wand_rfkill_wifi_probe(struct device *dev,
+		struct device_node *np,
+		struct wand_rfkill_data *rfkill,
+		int wand_rev)
+{
+	int ret;
+	int wl_ref_on, wl_rst_n, wl_reg_on, wl_wake, wl_host_wake;
+
+	if(wand_rev){
+	    wl_ref_on = of_get_named_gpio(np, "wifi-ref-on-revc1", 0);
+	    wl_rst_n = of_get_named_gpio(np, "wifi-rst-n-revc1", 0);
+	}
+	else {
+	    wl_ref_on = of_get_named_gpio(np, "wifi-ref-on", 0);
+	    wl_rst_n = of_get_named_gpio(np, "wifi-rst-n", 0);
+	}
+
+	wl_reg_on = of_get_named_gpio(np, "wifi-reg-on", 0);
+	wl_wake = of_get_named_gpio(np, "wifi-wake", 0);
+	wl_host_wake = of_get_named_gpio(np, "wifi-host-wake", 0);
+
+	if (!gpio_is_valid(wl_rst_n) || !gpio_is_valid(wl_ref_on) ||
+			!gpio_is_valid(wl_reg_on) || !gpio_is_valid(wl_wake) ||
+			!gpio_is_valid(wl_host_wake)) {
+
+		dev_err(dev, "incorrect wifi gpios (%d %d %d %d %d)\n",
+				wl_rst_n, wl_ref_on, wl_reg_on, wl_wake, wl_host_wake);
+		return -EINVAL;
+	}
+
+	dev_info(dev, "initialize wifi chip\n");
+
+	gpio_request(wl_rst_n, "wl_rst_n");
+	gpio_direction_output(wl_rst_n, 0);
+	msleep(11);
+	gpio_set_value(wl_rst_n, 1);
+
+	gpio_request(wl_ref_on, "wl_ref_on");
+	gpio_direction_output(wl_ref_on, 1);
+
+	gpio_request(wl_reg_on, "wl_reg_on");
+	gpio_direction_output(wl_reg_on, 1);
+
+	gpio_request(wl_wake, "wl_wake");
+	gpio_direction_output(wl_wake, 1);
+
+	gpio_request(wl_host_wake, "wl_host_wake");
+	gpio_direction_input(wl_host_wake);
+
+	rfkill->shutdown_name = "wifi_shutdown";
+	rfkill->shutdown_gpio = wl_wake;
+
+	rfkill->rfkill_dev = rfkill_alloc("wifi-rfkill", dev, RFKILL_TYPE_WLAN,
+			&wand_rfkill_ops, rfkill);
+	if (!rfkill->rfkill_dev) {
+		ret = -ENOMEM;
+		goto wifi_fail_free_gpio;
+	}
+
+	ret = rfkill_register(rfkill->rfkill_dev);
+	if (ret < 0)
+		goto wifi_fail_unregister;
+
+	dev_info(dev, "wifi-rfkill registered.\n");
+
+	return 0;
+
+wifi_fail_unregister:
+	rfkill_destroy(rfkill->rfkill_dev);
+wifi_fail_free_gpio:
+	if (gpio_is_valid(wl_rst_n))     gpio_free(wl_rst_n);
+	if (gpio_is_valid(wl_ref_on))    gpio_free(wl_ref_on);
+	if (gpio_is_valid(wl_reg_on))    gpio_free(wl_reg_on);
+	if (gpio_is_valid(wl_wake))      gpio_free(wl_wake);
+	if (gpio_is_valid(wl_host_wake)) gpio_free(wl_host_wake);
+
+	return ret;
+}
+
+static int wand_rfkill_bt_probe(struct device *dev,
+		struct device_node *np,
+		struct wand_rfkill_data *rfkill,
+		int wand_rev)
+{
+	int ret;
+	int bt_on, bt_wake, bt_host_wake;
+
+	if(wand_rev) {
+	    bt_on = of_get_named_gpio(np, "bluetooth-on-revc1", 0);
+	    bt_wake = of_get_named_gpio(np, "bluetooth-wake-revc1", 0);
+	    bt_host_wake = of_get_named_gpio(np, "bluetooth-host-wake-revc1", 0);
+	}
+	else{
+	    bt_on = of_get_named_gpio(np, "bluetooth-on", 0);
+	    bt_wake = of_get_named_gpio(np, "bluetooth-wake", 0);
+	    bt_host_wake = of_get_named_gpio(np, "bluetooth-host-wake", 0);
+	}
+
+	if (!gpio_is_valid(bt_on) || !gpio_is_valid(bt_wake) ||
+			!gpio_is_valid(bt_host_wake)) {
+
+		dev_err(dev, "incorrect bt gpios (%d %d %d)\n",
+				bt_on, bt_wake, bt_host_wake);
+		return -EINVAL;
+	}
+
+	dev_info(dev, "initialize bluetooth chip\n");
+
+	gpio_request(bt_on, "bt_on");
+	gpio_direction_output(bt_on, 0);
+	msleep(11);
+	gpio_set_value(bt_on, 1);
+
+	gpio_request(bt_wake, "bt_wake");
+	gpio_direction_output(bt_wake, 1);
+
+	gpio_request(bt_host_wake, "bt_host_wake");
+	gpio_direction_input(bt_host_wake);
+
+	rfkill->shutdown_name = "bluetooth_shutdown";
+	rfkill->shutdown_gpio = bt_wake;
+
+	rfkill->rfkill_dev = rfkill_alloc("bluetooth-rfkill", dev, RFKILL_TYPE_BLUETOOTH,
+			&wand_rfkill_ops, rfkill);
+	if (!rfkill->rfkill_dev) {
+		ret = -ENOMEM;
+		goto bt_fail_free_gpio;
+	}
+
+	ret = rfkill_register(rfkill->rfkill_dev);
+	if (ret < 0)
+		goto bt_fail_unregister;
+
+	dev_info(dev, "bluetooth-rfkill registered.\n");
+
+	return 0;
+
+bt_fail_unregister:
+	rfkill_destroy(rfkill->rfkill_dev);
+bt_fail_free_gpio:
+	if (gpio_is_valid(bt_on))        gpio_free(bt_on);
+	if (gpio_is_valid(bt_wake))      gpio_free(bt_wake);
+	if (gpio_is_valid(bt_host_wake)) gpio_free(bt_host_wake);
+
+	return ret;
+}
+
+static int wand_rfkill_probe(struct platform_device *pdev)
+{
+	struct wand_rfkill_data *rfkill;
+	struct pinctrl *pinctrl;
+	int ret;
+	int wand_rev_gpio;
+	int wand_rev;
+
+	dev_info(&pdev->dev, "Wandboard rfkill initialization\n");
+
+	if (!pdev->dev.of_node) {
+		dev_err(&pdev->dev, "no device tree node\n");
+		return -ENODEV;
+	}
+
+	rfkill = kzalloc(sizeof(*rfkill) * 2, GFP_KERNEL);
+	if (!rfkill)
+		return -ENOMEM;
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		int ret = PTR_ERR(pinctrl);
+		dev_err(&pdev->dev, "failed to get default pinctrl: %d\n", ret);
+		return ret;
+	}
+
+	/* GPIO for detecting C1 revision of Wandboard */
+	wand_rev_gpio = of_get_named_gpio(pdev->dev.of_node, "wand-rev-gpio", 0);
+	if (!gpio_is_valid(wand_rev_gpio)) {
+
+		dev_err(&pdev->dev, "incorrect Wandboard revision check gpio (%d)\n",
+				wand_rev_gpio);
+		return -EINVAL;
+	}
+
+	gpio_request(wand_rev_gpio, "wand-rev-gpio");
+	dev_info(&pdev->dev, "initialized Wandboard revision check gpio (%d)\n",
+			wand_rev_gpio);
+	gpio_direction_input(wand_rev_gpio);
+
+	/* Check Wandboard revision */
+	wand_rev = gpio_get_value(wand_rev_gpio);
+	if(wand_rev)
+		dev_info(&pdev->dev,"wandboard is rev C1\n");
+	else
+		dev_info(&pdev->dev,"wandboard is rev B0\n");
+
+	/* setup WiFi */
+	ret = wand_rfkill_wifi_probe(&pdev->dev, pdev->dev.of_node, &rfkill[0], wand_rev);
+	if (ret < 0)
+		goto fail_free_rfkill;
+
+	/* setup bluetooth */
+	ret = wand_rfkill_bt_probe(&pdev->dev, pdev->dev.of_node, &rfkill[1], wand_rev);
+	if (ret < 0)
+		goto fail_unregister_wifi;
+
+	platform_set_drvdata(pdev, rfkill);
+
+	return 0;
+
+fail_unregister_wifi:
+	if (rfkill[1].rfkill_dev) {
+		rfkill_unregister(rfkill[1].rfkill_dev);
+		rfkill_destroy(rfkill[1].rfkill_dev);
+	}
+
+	/* TODO free gpio */
+
+fail_free_rfkill:
+	kfree(rfkill);
+
+	return ret;
+}
+
+static int wand_rfkill_remove(struct platform_device *pdev)
+{
+	struct wand_rfkill_data *rfkill = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "Module unloading\n");
+
+	if (!rfkill)
+		return 0;
+
+	/* WiFi */
+	if (gpio_is_valid(rfkill[0].shutdown_gpio))
+		gpio_free(rfkill[0].shutdown_gpio);
+
+	rfkill_unregister(rfkill[0].rfkill_dev);
+	rfkill_destroy(rfkill[0].rfkill_dev);
+
+	/* Bt */
+	if (gpio_is_valid(rfkill[1].shutdown_gpio))
+		gpio_free(rfkill[1].shutdown_gpio);
+
+	rfkill_unregister(rfkill[1].rfkill_dev);
+	rfkill_destroy(rfkill[1].rfkill_dev);
+
+	kfree(rfkill);
+
+	return 0;
+}
+
+static struct of_device_id wand_rfkill_match[] = {
+	{ .compatible = "wand,imx6q-wandboard-rfkill", },
+	{ .compatible = "wand,imx6dl-wandboard-rfkill", },
+	{ .compatible = "wand,imx6qdl-wandboard-rfkill", },
+	{}
+};
+
+static struct platform_driver wand_rfkill_driver = {
+	.driver = {
+		.name = "wandboard-rfkill",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(wand_rfkill_match),
+	},
+	.probe = wand_rfkill_probe,
+	.remove = wand_rfkill_remove
+};
+
+module_platform_driver(wand_rfkill_driver);
+
+MODULE_AUTHOR("Vladimir Ermakov <vooon341@gmail.com>");
+MODULE_DESCRIPTION("Wandboard rfkill driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mxc/ipu3/ipu_param_mem.h b/drivers/mxc/ipu3/ipu_param_mem.h
index 2ff622b5..461d23f 100644
--- a/drivers/mxc/ipu3/ipu_param_mem.h
+++ b/drivers/mxc/ipu3/ipu_param_mem.h
@@ -399,7 +399,7 @@ static inline void _ipu_ch_param_init(struct ipu_soc *ipu, int ch,
 			ipu_ch_param_set_field(&params, 1, 78, 7, 15);  /* burst size */
 			uv_stride = uv_stride*2;
 		} else {
-			ipu_ch_param_set_field(&params, 1, 78, 7, 31);  /* burst size */
+			ipu_ch_param_set_field(&params, 1, 78, 7, 63);  /* burst size */
 		}
 		break;
 	case IPU_PIX_FMT_YVU422P:
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 43ccd29..4010f91 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -1021,6 +1021,9 @@ static u8 hdmi_edid_i2c_read(struct mxc_hdmi *hdmi,
 	return data;
 }
 
+static int keepalive=1;
+module_param(keepalive, int, 0644);
+MODULE_PARM_DESC(keepalive, "Allow only CEA modes");
 
 /* "Power-down enable (active low)"
  * That mean that power up == 1! */
@@ -2078,6 +2081,7 @@ static void hotplug_worker(struct work_struct *work)
 	u32 hdmi_phy_stat0, hdmi_phy_pol0, hdmi_phy_mask0;
 	unsigned long flags;
 	char event_string[32];
+	int isalive = 0;
 	char *envp[] = { event_string, NULL };
 
 	hdmi_phy_stat0 = hdmi_readb(HDMI_PHY_STAT0);
@@ -2100,7 +2104,11 @@ static void hotplug_worker(struct work_struct *work)
 			mxc_hdmi_cec_handle(0x80);
 #endif
 			hdmi_set_cable_state(1);
-		} else {
+
+			if (keepalive)
+				 hdmi_writeb(hdmi->plug_mask, HDMI_PHY_POL0);
+			isalive=1;
+		} else if (!keepalive) {
 			/* Plugout event */
 			dev_dbg(&hdmi->pdev->dev, "EVENT=plugout\n");
 			hdmi_set_cable_state(0);
@@ -2119,16 +2127,18 @@ static void hotplug_worker(struct work_struct *work)
 	 * completed before next interrupt processed */
 	spin_lock_irqsave(&hdmi->irq_lock, flags);
 
-	/* Re-enable HPD interrupts */
-	hdmi_phy_mask0 = hdmi_readb(HDMI_PHY_MASK0);
-	hdmi_phy_mask0 &= ~hdmi->plug_mask;
-	hdmi_writeb(hdmi_phy_mask0, HDMI_PHY_MASK0);
+	if (!(keepalive || isalive)) {
+		/* Re-enable HPD interrupts */
+		hdmi_phy_mask0 = hdmi_readb(HDMI_PHY_MASK0);
+		hdmi_phy_mask0 &= ~hdmi->plug_mask;
+		hdmi_writeb(hdmi_phy_mask0, HDMI_PHY_MASK0);
 
-	/* Unmute interrupts */
-	hdmi_writeb(~hdmi->plug_event, HDMI_IH_MUTE_PHY_STAT0);
+		/* Unmute interrupts */
+		hdmi_writeb(~hdmi->plug_event, HDMI_IH_MUTE_PHY_STAT0);
 
-	if (hdmi_readb(HDMI_IH_FC_STAT2) & HDMI_IH_FC_STAT2_OVERFLOW_MASK)
-		mxc_hdmi_clear_overflow(hdmi);
+		if (hdmi_readb(HDMI_IH_FC_STAT2) & HDMI_IH_FC_STAT2_OVERFLOW_MASK)
+			mxc_hdmi_clear_overflow(hdmi);
+	}
 
 	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
 }
